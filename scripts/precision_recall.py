# from a specified cut-off value, determine the precision and recall
# as the cohort is small, I will use the entire cohort as test set
# and use bootstrapping to estimate the confidence interval
# there is still an open question on whether the cohort should be representative of the general population,
# or if including enriched numbers of control carriers is acceptable
# the data used here is the one generated by plot_ct_vs_repeat_length.py (analysis_overview_golga8a_unphased.tsv)

import pandas as pd
from argparse import ArgumentParser
from sklearn.metrics import precision_score, recall_score
from scipy.stats import bootstrap




def main():
    args = get_args()
    df = pd.read_csv(args.data, sep="\t").drop_duplicates(subset=["name"])
    df = df[df["haplotype"].isin(["major", "minor"])]
    df["labels"] = df["group"].apply(lambda x: 1 if x == "aFTLD-U" else 0)

    print(f"Testing precision recall for the CT_dimer_count with a cutoff of {args.cutoff_CT_dimer}")
    df["test"] = (df["CT_dimer_count"] > args.cutoff_CT_dimer).astype(int)
    precision_recall_bootstrapped(df)

    print(f"Testing precision recall for a combination of length and %CT with cutoffs {args.cutoff_double}")
    df["test"] = (df["length"] > args.cutoff_double[0]) & (df["%CT"] > args.cutoff_double[1]).astype(int)
    precision_recall_bootstrapped(df)

def precision_recall_bootstrapped(df):
    prec = precision_score(df["labels"], df["test"])
    res = bootstrap([df["labels"], df["test"]], precision_score, n_resamples=10000, paired=True)
    print(f"\tPrecision: {prec:.2f}, 95% CI: {res.confidence_interval.low:.2f}-{res.confidence_interval.high:.2f}")
    recall = recall_score(df["labels"], df["test"])
    res = bootstrap((df["labels"], df["test"]), recall_score, n_resamples=10000, paired=True)
    print(f"\tRecall: {recall:.2f}, 95% CI: {res.confidence_interval.low:.2f}-{res.confidence_interval.high:.2f}")



def get_args():
    parser = ArgumentParser(description="Calculate precision and recall")
    parser.add_argument("--data", help="path to data file", required=True)
    parser.add_argument("--cutoff_CT_dimer", help="cutoff value for the CT_dimer_count", required=True, type=float)
    parser.add_argument("--cutoff_double", help="length cutoff to use in combined filter", required=True, type=float, nargs=2)
    return parser.parse_args()


if __name__ == "__main__":
    main()
